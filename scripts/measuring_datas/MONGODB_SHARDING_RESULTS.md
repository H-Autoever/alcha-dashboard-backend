# MongoDB 샤딩 성능 검증 결과

## 📋 샤딩 클러스터 구성

### 아키텍처
- **Config Server**: 3개 (Replica Set)
- **Shard Server 1**: 3개 (Replica Set)
- **Shard Server 2**: 3개 (Replica Set)
- **Mongos Router**: 1개 (클라이언트 연결 지점)

### 샤드 키 전략
- **컬렉션**: `realtime-storage-data`, `periodic-storage-data`, `event-*`
- **샤드 키**: `vehicle_id` (Hashed)
- **목적**: 차량별 데이터를 샤드 간 균등 분산

---

## 📝 테스트 결과

### 테스트 1: 샤딩된 MongoDB 쓰기 성능

**테스트 데이터**: 50,000개 레코드 (일반 테스트 10,000개 대비 5배 증가)

| 배치 크기 | 총 레코드 | 총 시간 | 초당 처리 | 배치당 평균 |
|----------|----------|---------|----------|------------|
| 1,000 | 50,000개 | 1,131.78ms | 44,178 레코드/초 | 22.64ms |
| **5,000** | **50,000개** | **884.36ms** | **56,538 레코드/초** | **88.44ms** |
| 10,000 | 50,000개 | 1,157.78ms | 43,186 레코드/초 | 231.56ms |

**최적 성능**: 배치 크기 5,000, 초당 처리 56,538 레코드/초

**참고**: 샤딩 클러스터 환경에서는 일반 단일 MongoDB 인스턴스보다 오버헤드가 있습니다.
- Mongos 라우터를 통한 라우팅 오버헤드
- 여러 샤드 서버 간 통신 오버헤드
- 샤드 키 기반 데이터 분산 처리

### 테스트 2: 샤딩된 MongoDB 읽기 성능

**테스트 데이터**: 실제 텔레메트리 데이터 10,800개

| 쿼리 타입 | 평균 시간 | 최소 시간 | 최대 시간 | 결과 개수 |
|----------|----------|----------|----------|----------|
| 단일 차량 시간 범위 쿼리 | 81.38ms | 24.26ms | 328.01ms | 3,600개 |
| 다중 차량 시간 범위 쿼리 | 85.45ms | 67.65ms | 127.09ms | 10,800개 |
| 집계 쿼리 (평균/최대/최소) | 8.35ms | 4.94ms | 35.74ms | 1개 |
| 전체 컬렉션 스캔 | 52.97ms | 46.28ms | 64.57ms | 10,000개 |

---

## 📊 샤딩 전후 성능 비교

### 쓰기 성능 비교

| 환경 | 최적 쓰기 성능 | 배치 크기 | 데이터량 |
|------|---------------|----------|---------|
| **일반 MongoDB** | 168,501 레코드/초 | 10,000 | 10,000개 |
| **샤딩 클러스터** | 56,538 레코드/초 | 5,000 | 50,000개 |

**분석**:
- 샤딩 클러스터는 소규모 데이터에서는 오버헤드로 인해 성능이 낮을 수 있음
- 하지만 **대량 데이터 처리**에서는 샤딩의 이점이 나타남:
  - 데이터가 여러 샤드에 분산되어 병렬 처리 가능
  - 샤드별 독립적인 I/O 처리
  - 수평 확장 가능

### 읽기 성능 비교

| 쿼리 타입 | 일반 MongoDB | 샤딩 클러스터 | 차이 |
|----------|-------------|--------------|------|
| 단일 차량 시간 범위 쿼리 | 20.44ms | 81.38ms | 샤딩이 약 4배 느림 |
| 집계 쿼리 | 5.59ms | 8.35ms | 샤딩이 약 1.5배 느림 |

**분석**:
- 소규모 데이터에서는 샤딩 오버헤드로 인해 성능 저하
- 하지만 **대규모 데이터**에서는 샤딩의 이점이 나타남:
  - 샤드별 병렬 쿼리 실행
  - 각 샤드가 전체 데이터의 일부만 처리

---

## 🎯 샤딩의 장점과 단점

### 장점 ✅

1. **수평 확장성**
   - 데이터 증가에 따라 샤드 추가 가능
   - 메모리 및 디스크 용량 제한 해결

2. **병렬 처리**
   - 여러 샤드에서 동시에 쿼리 실행
   - 집계 쿼리의 샤드별 병렬 처리

3. **장애 격리**
   - 한 샤드의 장애가 전체 시스템에 미치는 영향 최소화
   - Replica Set과 결합하여 고가용성 제공

4. **대규모 데이터 처리**
   - 샤드별로 데이터가 분산되어 각 샤드의 데이터량 감소
   - 큰 데이터셋에서 성능 향상

### 단점 ⚠️

1. **오버헤드**
   - Mongos 라우터를 통한 라우팅 오버헤드
   - 여러 샤드 간 통신 오버헤드
   - Config Server 관리 오버헤드

2. **소규모 데이터에서 성능 저하**
   - 소규모 데이터에서는 단일 인스턴스보다 느릴 수 있음
   - 샤드 키 기반 라우팅 오버헤드

3. **복잡성 증가**
   - 클러스터 관리 복잡도 증가
   - 샤드 키 선택이 중요 (잘못 선택 시 성능 저하)

---

## 💡 샤딩 사용 권장 시나리오

### 샤딩을 사용해야 하는 경우 ✅

1. **대량 데이터 처리**
   - 데이터가 단일 서버 메모리/디스크 용량을 초과할 때
   - 수백만 ~ 수십억 개의 레코드 처리

2. **높은 쓰기 처리량 필요**
   - 초당 수만 ~ 수십만 건의 쓰기 필요
   - 단일 서버의 처리 용량 초과

3. **지리적 분산**
   - 데이터를 지리적으로 분산 저장 필요
   - 지역별 샤드 구성

4. **수평 확장성 필요**
   - 데이터 증가에 따른 확장 계획이 있을 때
   - 샤드 추가로 용량 확장

### 샤딩을 사용하지 않아도 되는 경우 ❌

1. **소규모 데이터**
   - 수만 ~ 수십만 개의 레코드
   - 단일 서버로 충분한 용량

2. **낮은 쓰기 처리량**
   - 초당 수천 건 이하의 쓰기
   - 단일 서버로 충분한 처리량

3. **간단한 아키텍처 필요**
   - 클러스터 관리 복잡도 최소화
   - 단일 인스턴스로 충분한 성능

---

## 🏗️ 현재 프로젝트 적용 권장사항

### 현재 상황
- **데이터 규모**: 10,800개 레코드 (소규모)
- **쓰기 처리량**: 초당 수백 ~ 수천 건 예상

### 권장사항

**현재 단계에서는 샤딩 불필요** ❌
- 데이터 규모가 샤딩의 이점을 활용하기에 충분하지 않음
- 샤딩 오버헤드로 인해 성능 저하 가능
- 단일 MongoDB 인스턴스로 충분

**샤딩 도입 시점** ✅
- 데이터가 수백만 ~ 수천만 개 이상일 때
- 초당 수만 건 이상의 쓰기 처리량 필요할 때
- 단일 서버의 메모리/디스크 용량 한계 도달 시

### 샤딩 도입 전 고려사항

1. **샤드 키 선택**
   - 현재: `vehicle_id` (hashed) - 적절
   - 균등한 데이터 분산을 위한 샤드 키 선택 중요

2. **Replica Set 구성**
   - 각 샤드를 Replica Set으로 구성하여 고가용성 확보
   - 현재 구성: 각 샤드 3개 멤버

3. **성능 모니터링**
   - 샤드별 성능 모니터링
   - Balancer 동작 확인
   - Chunk 분산 상태 확인

---

## 📝 결론

### 성능 검증 결과

1. **소규모 데이터 환경**:
   - 샤딩 클러스터가 일반 MongoDB보다 성능 저하 (오버헤드)
   - 쓰기: 약 3배 느림
   - 읽기: 약 4배 느림

2. **대규모 데이터 환경**:
   - 샤딩의 이점이 나타남 (예상)
   - 병렬 처리로 성능 향상
   - 수평 확장 가능

### 최종 권장사항

**현재 프로젝트 단계**:
- ✅ **일반 MongoDB 인스턴스 사용** (단일 서버)
- ✅ 샤딩은 미래 확장 계획에 포함

**향후 확장 계획**:
- 데이터 규모 증가 시 샤딩 도입 검토
- 초당 수만 건 이상 쓰기 처리량 필요 시 샤딩 도입
- 샤드 키 전략 사전 수립

---

## 🔗 참고 자료

- MongoDB 샤딩 아키텍처: https://docs.mongodb.com/manual/sharding/
- 샤드 키 선택 가이드: https://docs.mongodb.com/manual/core/sharding-shard-key/
- 샤딩 성능 최적화: https://docs.mongodb.com/manual/sharding/#performance

